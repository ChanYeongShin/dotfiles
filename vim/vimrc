" colorscheme
syntax enable "make colorscheme work on mac
colorscheme jellybeans


filetype plugin on  "understand file types
set pastetoggle=<f2> "togle paste mode
autocmd FileType * set formatoptions-=o "disable autoindent


" pick up cursor where last left
au BufReadPost *
\ if line("'\"") > 0 && line("'\"") <= line("$") |
\ exe "norm g`\"" |
\ endif


"autosave
autocmd TextChanged,TextChangedI <buffer> silent write


"automatically strip trailing whitespace when a file is saved
autocmd BufWritePre * :%s/\s\+$//e


" Cursor shape
" https://nickjanetakis.com/blog/change-your-vim-cursor-from-a-block-to-line-in-normal-and-insert-mode
" Use a line cursor within insert mode and a block cursor everywhere else.
" Reference chart of values:
"   Ps = 0  -> blinking block.
"   Ps = 1  -> blinking block (default).
"   Ps = 2  -> steady block.
"   Ps = 3  -> blinking underline.
"   Ps = 4  -> steady underline.
"   Ps = 5  -> blinking bar (xterm).
"   Ps = 6  -> steady bar (xterm).
let &t_SI = "\e[6 q"
let &t_EI = "\e[2 q"


" various basic options
set nocompatible    "disable compatibility to old-time vi
set number          "line number on the left
set autoindent      "autoindent
set nohlsearch      "no highlight search (better use easymotion)
set ignorecase      "ignore case for search
set incsearch       "show search result for input character
set showmatch       "highlight matching brackets
set mouse=a         "allow mouse
set ts=4            "tap size
set sw=4            "shift width for use with >, <, or =
set expandtab       "spaces instead of tabs; `:retab` to change taps to spaces
set sts=4           "make spaces feel like tabs (like deleting)
set colorcolumn=80  "show vertical line at column 80
set nowrap          "no wraparound trailing characters
set scrolloff=10    "show code above and below cursor
set list            "make whitespaces visible
set listchars=tab:>-,trail:~,extends:>,precedes:<
set nostartofline   "keep column position when c-u or c-d



"display cursorline
set cursorline
set cursorcolumn


"Show no cursorline on insert mode
"autocmd insertenter * set nocursorline
"autocmd insertleave * set cursorline
"autocmd insertenter * set nocursorcolumn
"autocmd insertleave * set cursorcolumn


"jk to escape insert mode
inoremap jk <esc>


"use system clipboard depending on context
set clipboard=unnamed
nnoremap dd "add
"paste without overriding curent register
vnoremap p pgvy


"indent/unindent faster
vnoremap > >gv
vnoremap < <gv
nnoremap > >>
nnoremap < <<


"left/down/up/left faster
noremap H ^
noremap J 5j
noremap K 5k
noremap L $


"move with current line up/down
" noremap U <cmd>m-2<cr>
" noremap M <cmd>m+1<cr>


"exit visual mode
vnoremap <space> <c-c>


"split panes
nnoremap <space>h :vs<cr>
nnoremap <space>j :sp<cr><c-w>j
nnoremap <space>k :sp<cr>
nnoremap <space>l :vs<cr><c-w>l


"remap :w and :q
nnoremap <space>w :w<cr>
nnoremap <space>q :q<cr>


"reload .vimrc
nnoremap <space>r :source $MYVIMRC<cr>


" plugin: vim-commentary
nmap ; gcc
vmap ; gcgv


" plugin: vim-mucomplete
set completeopt+=menuone
set completeopt+=noselect
let g:mucomplete#enable_auto_at_startup = 1
let g:mucomplete#no_mappings = 1


"plugin: vim-airline
" let g:airline_powerline_fonts = 1
let g:airline_symbols_ascii = 1


" plugin: vim-easymotion
nnoremap <cr> <Plug>(easymotion-overwin-w)
vnoremap <cr> <Plug>(easymotion-bd-jk)
nnoremap ' <Plug>(easymotion-lineanywhere)
vnoremap ' <Plug>(easymotion-lineanywhere)

" Better than vim default search
map  / <Plug>(easymotion-sn)
omap / <Plug>(easymotion-tn)
" These `n` & `N` mappings are options. You do not have to map `n` & `N` to EasyMotion.
" Without these mappings, `n` & `N` works fine. (These mappings just provide
" different highlight method and have some other features )
map  n <Plug>(easymotion-next)
map  N <Plug>(easymotion-prev)






"plugin: vim-fzf
set rtp+=~/.fzf

"vim-fzf settings from Wookayin
function! Trim(input_string)
    return substitute(a:input_string, '^\s*\(.\{-}\)\s*$', '\1', '')
endfunction

function! s:get_git_dir(path)
  let curr = fnamemodify(expand(a:path), ':p')
  if empty(curr)   " empty buffer, etc.: fall back to current dir
    let curr = getcwd()
  endif
  try
    return FugitiveExtractGitDir(curr)
  catch /E117/  " Unknown function: maybe incompatible fugitive
    return fugitive#extract_git_dir(curr)
  endtry
endfunction

" Command :F (FzfSmart)
function! FzfSmart(path) abort
  " If args are given (e.g. :F <args>), run :Files <args>
  let l:path = Trim(a:path)
  if !empty(l:path)
    let l:path = expand(l:path)
    if !isdirectory(l:path)   " for a file, the directory that contains it
      if filereadable(l:path)
        let l:path = fnamemodify(l:path, ":h")
      else  " does not exist, error
        echohl WarningMsg | call Echom('Does not exist: ' . l:path) | echohl NONE | return 0
      endif
    endif
  endif

  " (1) If a FZF tree/explorer is shown with no argument,
  " invoke :Files (with preview) rather than :GFiles
  if empty(l:path) && index(['nerdtree'], &filetype) >= 0
    let l:target_path = b:NERDTree.root.path._str()
    " if the current buffer is the pinned on in the tab (vim-nerdtree-tabs),
    " let fzf open files in another window. Otherwise, open in the current window.
    if exists('t:NERDTreeBufName') && bufname('%') == t:NERDTreeBufName
      wincmd w   " we need to move the focus outside nerdtree
    endif
    call fzf#vim#files(l:target_path, fzf#vim#with_preview())
    return 1
  endif

  " (2) If the given path (or CWD) is in a git repo,
  " invoke :GFiles (plus untracked files)
  let l:git_dir = s:get_git_dir(!empty(l:path) ? l:path : '%')
  if ! empty(l:git_dir)
    let l:old_cwd = getcwd()
    execute ':tcd ' . l:git_dir . '/..'
    echon ':GFiles (' | echohl Directory | echon getcwd() | echohl NONE | echon ')' | echon '    '
    GFiles -c -o --exclude-standard
    execute ':tcd ' . l:old_cwd
    return 2

  " (3) not in git repo, invoke :Files <args> by fallback
  else
    execute ':Files ' . l:path
    return 3
  endif
endfunction

" :F is a shortcut for :GFiles or :FZF
command! -complete=dir -nargs=* F        call FzfSmart(<q-args>)

" Invoke F (FZF) Using Ctrl-P
" nmap <C-P> :bw<cr>:F<CR>
" nmap <C-P> :F<CR>
nmap <space><space> :History<cr>
nmap <space>o :F<cr>






